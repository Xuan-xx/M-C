# 传教士(牧师)与野人问题
- 广州大学2021人工智能实验1
>问题描述：
>有n个牧师和n个野人准备渡河，但只有一条能容纳c个人的小船，为了防止野人侵犯牧师，要求无论在何处，牧师的人数不得少于野人的人数(除非牧师人数为0)，且假定野人与牧师都会划船，试设计一个算法，确定他们能否渡过河去，若能，则给出小船来回次数最少的最佳方案。
>
>实验步骤：
>输入：牧师人数(即野人人数)：n；小船一次最多载人量：c。  
>输出：若问题无解，则显示Failed，否则，显示Successed输出所有可行方案，并标注哪一组是最佳方案。用三元组(X1, X2, X3)表示渡河过程中的状态。并用箭头连接相邻状态以表示迁移过程：初始状态->中间状态->目标状态。   
>
>例：当输入n=2，c=2时，输出：221->200->211->010->021->000；  
>其中：X1表示起始岸上的牧师人数；X2表示起始岸上的野人人数；X3表示小船现在位置(1表示起始岸，0表示目的岸)。 
>要求：写出算法的设计思想和源程序，并有用户界面实现人机交互（控制台或者窗口都可以），进行输入和输出结果，如：  
>
>Please input n: 2         Please input c: 2 
>
>Optimal Procedure: 221->200->211->010->021->000
>
>Successed or Failed?: Successed

---

### 数据结构
```
class LState:  # 左岸状态类
    def __init__(self, m, w, b):
        self.m = m  # 左岸传教士人数(missionary
        self.w = w  # 左岸野人人数(wild
        self.b = b  # 船在左岸为1，在右岸为0
        self.parent = []
        self.son = []

class Operate:  # 操作类
    def __init__(self, m, w):
        self.m = m
        self.w = w
```

---


### 算法
- 代码使用广度优先方式实现
1. 根据传教士和野人的人数N、船可载人数C举出所有合法操作
2. 设置一个列表open和close，用于存放刚生成的结点和将要扩展的结点.设置一个列表M，用于存放出现过的状态
3. 将初始状态（NN1）存入open
4. 如果open为空，寻找结束
5. 将open的值放到close（清空open），然后对每一个close中的结点进行扩展操作 
6. 对扩展生成的结点状态进行判断：
> - 如果是（000）,打印路径，不加入open和M
> - 没有在M中出现过的加入open，修改父结点指向
> - 在M中出现过的，并且该状态与任意一个祖先结点相同，舍弃,不加入open
> - 在M中出现过，但没有在祖先结点出现过的，修改父结点指向
7. 回到4

---
### 结果
![IMAGE](https://github.com/Xuan-xx/M-C/blob/main/IMG/2021-09-14_01-35.jpg)
  
![IMAGE](https://github.com/Xuan-xx/M-C/blob/main/IMG/2021-09-14_01-35_1.jpg)
   
![IMAGE](https://github.com/Xuan-xx/M-C/blob/main/IMG/2021-09-14_01-36.jpg)
